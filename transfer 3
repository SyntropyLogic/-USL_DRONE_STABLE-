

im going to implement your recomendations which have been great so it would make more sense to actually gice you the context that we are working with ill share some files and let you know how the new strategy goes, buy yeah thought maybe it could be something small oversight thats stuffing it up. and also since i have ectern control wothn files does that mean the setting i found in webots fine as it is with nothing?

#iris.parm
FRAME_CLASS      1          # Multirotor
FRAME_TYPE       1          # X class

ATC_ANG_PIT_P    0.5
ATC_ANG_RLL_P    0.5
ATC_ANG_YAW_P    0.5

ATC_RAT_PIT_P    0.05
ATC_RAT_RLL_P    0.05
ATC_RAT_YAW_P    0.02 

ATC_RAT_PIT_I    0
ATC_RAT_RLL_I    0

ATC_RAT_PIT_D    0.0003
ATC_RAT_RLL_D    0.0003  
ATC_RAT_YAW_D    0.000001

AHRS_EKF_TYPE    10         # Use sim AHRS
ARMING_CHECK	 1045534    # No RC requirements
MOT_THST_EXPO    0          # No motor exponential
SCHED_LOOP_RATE  250        
INS_GYR_CAL      0

#iris.proto
# VRML_SIM R2022b utf8
# Iris drone model. Note that the model is not 1-to-1 with the 
# real drone as motor/propeller constants were empirically determined.

PROTO Iris [
  field  SFVec3f     translation     0 0 0
  field  SFRotation  rotation        0 0 1 0
  field  SFString    name            "Iris"  # Is `Robot.name`.
  field  SFString    controller      "void"  # Is `Robot.controller`.
  field  MFString    controllerArgs  []      # Is `Robot.controllerArgs`.
  field  SFString    customData      ""      # Is `Robot.customData`.
  field  SFBool      supervisor      FALSE   # Is `Robot.supervisor`.
  field  SFBool      synchronization TRUE    # Is `Robot.synchronization`.
  field  MFNode      extensionSlot   []      # Extends the robot with new nodes in the extension slot.
]
{
  Robot {
    translation IS translation
    rotation IS rotation
    controller IS controller
    controllerArgs IS controllerArgs
    customData IS customData
    supervisor IS supervisor
    synchronization IS synchronization
    name IS name
    children [
      Group {
        children IS extensionSlot
      }
      DEF IRIS_MESH Shape {
        appearance PBRAppearance {
          baseColor 0.05 0.05 0.05
          roughness 1.000000
          metalness 0.2
        }
        geometry Mesh {
          url "meshes/iris.dae"
        }
        castShadows FALSE
      }
      Propeller {
        shaftAxis 0 0 1
        centerOfThrust 0.130000 -0.220000 0.023000
        thrustConstants 0.0012 0
        torqueConstants 5.0e-04 0
        device RotationalMotor {
          name "m1_motor"
          maxVelocity 100
          maxTorque 30
          multiplier 1
        }
        slowHelix Solid {
          translation 0.130000 -0.220000 0.023000
          children [
            Shape {
              appearance DEF PROP_BLUE PBRAppearance {
                baseColor 0 0 0.75
                metalness 0.3
              }
              geometry DEF CCW_PROP Mesh {
                url [
                  "meshes/iris_prop_ccw.dae"
                ]
              }
            }
          ]
        }
      }
      Propeller {
        shaftAxis 0 0 1
        centerOfThrust -0.130000 0.200000 0.023000
        thrustConstants 0.0012 0
        torqueConstants 5.0e-04 0
        device RotationalMotor {
          name "m2_motor"
          maxVelocity 100
          maxTorque 30
          multiplier 1
        }
        slowHelix Solid {
          translation -0.130000 0.200000 0.023000
          children [
            Shape {
              appearance DEF PROP_BLACK PBRAppearance {
                baseColor 0 0 0
                metalness 0.3
              }
              geometry USE CCW_PROP
            }
          ]
        }
      }
      Propeller {
        shaftAxis 0 0 1
        centerOfThrust 00.130000 0.220000 0.023000
        thrustConstants -0.0012 0
        torqueConstants 5.0e-04 0
        device RotationalMotor {
          name "m3_motor"
          maxVelocity 100
          maxTorque 30
          multiplier -1
        }
        slowHelix Solid {
          translation 0.130000 0.220000 0.023000
          children [
            Shape {
              appearance USE PROP_BLUE
              geometry DEF CW_PROP Mesh {
                url [
                  "meshes/iris_prop_cw.dae"
                ]
              }
            }
          ]
        }
      }
      Propeller {
        shaftAxis 0 0 1
        centerOfThrust -0.130000 -0.200000 0.023000
        thrustConstants -0.0012 0
        torqueConstants 5.0e-04 0
        device RotationalMotor {
          name "m4_motor"
          maxVelocity 100
          maxTorque 30
          multiplier -1
        }
        slowHelix Solid {
          translation -0.130000 -0.200000 0.023000
          children [
            Shape {
              appearance USE PROP_BLACK
              geometry USE CW_PROP
            }
          ]
        }
      }
      Accelerometer {
      }
      GPS {
      }
      Gyro {
      }
      InertialUnit {
      }
    ]
    boundingObject Box {
       size 0.470000 0.470000 0.110000
    }
    physics Physics {
      density -1
      mass 1.500000
      centerOfMass [ 0.000000 0.000000 0.000000 ]
      inertiaMatrix [
        2.912500e-02 2.912500e-02 5.522500e-02
        0.000000e+00 0.000000e+00 0.000000e+00
      ]
    }
  }
}

#ardulilot_vehicle_controller.py
#!/usr/bin/env python3
'''
General ardupilot vehicle controller for Webots 2023a

AP_FLAKE8_CLEAN
'''


import time
import argparse
from webots_vehicle import WebotsArduVehicle


def get_args():
    parser = argparse.ArgumentParser()

    parser.add_argument("--motors", "-m",
                        type=str,
                        default="m1_motor, m2_motor, m3_motor, m4_motor",
                        help="Comma spaced list of motor names in ardupilot numerical order (ex --motors \"m1,m2,m3, m4\")")
    parser.add_argument("--reversed-motors", "-r",
                        type=str,
                        default=None,
                        help="Comma spaced list of motors to reverse (starting from 1, in ardupilot order)")
    parser.add_argument("--bidirectional-motors",
                        type=bool,
                        default=False,
                        help="If the motors are bidirectional (as is the case for Rovers usually)")
    parser.add_argument("--uses-propellers",
                        type=bool,
                        default=True,
                        help="Whether the vehicle uses propellers. This is important as we need to linearize thrust if so")
    parser.add_argument("--motor-cap",
                        type=float,
                        default=float('inf'),
                        help="Motor velocity cap. This is useful for the crazyflie which default has way too much power")

    parser.add_argument("--accel",
                        type=str,
                        default="accelerometer",
                        help="Webots accelerometer name")
    parser.add_argument("--imu",
                        type=str,
                        default="inertial unit",
                        help="Webots IMU name")
    parser.add_argument("--gyro",
                        type=str,
                        default="gyro",
                        help="Webots gyro name")
    parser.add_argument("--gps",
                        type=str,
                        default="gps",
                        help="Webots GPS name")

    parser.add_argument("--camera",
                        type=str,
                        default=None,
                        help="Webots Camera name (optional)")
    parser.add_argument("--camera-fps",
                        type=int,
                        default=10,
                        help="Camera FPS. Note lower FPS is faster")
    parser.add_argument("--camera-port",
                        type=int,
                        default=None,
                        help="Port to stream grayscale camera images to. "
                             "If no port is supplied the camera will not be streamed.")

    parser.add_argument("--rangefinder",
                        type=str,
                        default=None,
                        help="Webots RangeFinder name (optional)")
    parser.add_argument("--rangefinder-fps",
                        type=int,
                        default=10,
                        help="rangefinder FPS. Note lower FPS is faster")
    parser.add_argument("--rangefinder-port",
                        type=int,
                        default=None,
                        help="Port to stream grayscale rangefinder images to. "
                             "If no port is supplied the rangefinder will not be streamed.")

    parser.add_argument("--instance", "-i",
                        type=int,
                        default=0,
                        help="Drone instance to match the SITL. This allows multiple vehicles")
    parser.add_argument("--sitl-address",
                        type=str,
                        default="127.0.0.1",
                        help="IP address of the SITL (useful with WSL2 eg \"172.24.220.98\")")

    return parser.parse_args()


if __name__ == "__main__":
    args = get_args()

    # parse string arguments into lists
    motors = [x.strip() for x in args.motors.split(',')]
    if args.reversed_motors:
        reversed_motors = [int(x) for x in args.reversed_motors.split(",")]
    else:
        reversed_motors = []

    vehicle = WebotsArduVehicle(motor_names=motors,
                                reversed_motors=reversed_motors,
                                accel_name=args.accel,
                                imu_name=args.imu,
                                gyro_name=args.gyro,
                                gps_name=args.gps,
                                camera_name=args.camera,
                                camera_fps=args.camera_fps,
                                camera_stream_port=args.camera_port,
                                rangefinder_name=args.rangefinder,
                                rangefinder_fps=args.rangefinder_fps,
                                rangefinder_stream_port=args.rangefinder_port,
                                instance=args.instance,
                                motor_velocity_cap=args.motor_cap,
                                bidirectional_motors=args.bidirectional_motors,
                                uses_propellers=args.uses_propellers,
                                sitl_address=args.sitl_address)

    # User code (ex: connect via drone kit and take off)
    # ...

    while vehicle.webots_connected():
        time.sleep(1)

#webots_vehicle.py
'''
This file implements a class that acts as a bridge between ArduPilot SITL and Webots

AP_FLAKE8_CLEAN
'''

# Imports
import os
import sys
import time
import socket
import select
import struct
import numpy as np
from threading import Thread
from typing import List, Union

# Here we set up environment variables so we can run this script
# as an external controller outside of Webots (useful for debugging)
# https://cyberbotics.com/doc/guide/running-extern-robot-controllers
if sys.platform.startswith("win"):
    WEBOTS_HOME = "C:\\Program Files\\Webots"
elif sys.platform.startswith("darwin"):
    WEBOTS_HOME = "/Applications/Webots.app"
elif sys.platform.startswith("linux"):
    WEBOTS_HOME = "/usr/local/webots"
else:
    raise Exception("Unsupported OS")

if os.environ.get("WEBOTS_HOME") is None:
    os.environ["WEBOTS_HOME"] = WEBOTS_HOME
else:
    WEBOTS_HOME = os.environ.get("WEBOTS_HOME")

os.environ["PYTHONIOENCODING"] = "UTF-8"

# CRITICAL: Insert Webots path FIRST to override ROS controller
sys.path.insert(0, f"{WEBOTS_HOME}/lib/controller/python")

from controller import Robot, Camera, RangeFinder # noqa: E401, E402


class WebotsArduVehicle():
    """Class representing an ArduPilot controlled Webots Vehicle"""

    controls_struct_format = 'f'*16
    controls_struct_size = struct.calcsize(controls_struct_format)
    fdm_struct_format = 'd'*(1+3+3+3+3+3)
    fdm_struct_size = struct.calcsize(fdm_struct_format)

    def __init__(self,
                 motor_names: List[str],
                 accel_name: str = "accelerometer",
                 imu_name: str = "inertial unit",
                 gyro_name: str = "gyro",
                 gps_name: str = "gps",
                 camera_name: str = None,
                 camera_fps: int = 10,
                 camera_stream_port: int = None,
                 rangefinder_name: str = None,
                 rangefinder_fps: int = 10,
                 rangefinder_stream_port: int = None,
                 instance: int = 0,
                 motor_velocity_cap: float = float('inf'),
                 reversed_motors: List[int] = None,
                 bidirectional_motors: bool = False,
                 uses_propellers: bool = True,
                 sitl_address: str = "127.0.0.1"):
        """WebotsArduVehicle constructor

        Args:
            motor_names (List[str]): Motor names in ArduPilot numerical order (first motor is SERVO1 etc).
            accel_name (str, optional): Webots accelerometer name. Defaults to "accelerometer".
            imu_name (str, optional): Webots imu name. Defaults to "inertial unit".
            gyro_name (str, optional): Webots gyro name. Defaults to "gyro".
            gps_name (str, optional): Webots GPS name. Defaults to "gps".
            camera_name (str, optional): Webots camera name. Defaults to None.
            camera_fps (int, optional): Camera FPS. Lower FPS runs better in sim. Defaults to 10.
            camera_stream_port (int, optional): Port to stream grayscale camera images to.
                                                If no port is supplied the camera will not be streamed. Defaults to None.
            rangefinder_name (str, optional): Webots RangeFinder name. Defaults to None.
            rangefinder_fps (int, optional): RangeFinder FPS. Lower FPS runs better in sim. Defaults to 10.
            rangefinder_stream_port (int, optional): Port to stream rangefinder images to.
                                                     If no port is supplied the camera will not be streamed. Defaults to None.
            instance (int, optional): Vehicle instance number to match the SITL. This allows multiple vehicles. Defaults to 0.
            motor_velocity_cap (float, optional): Motor velocity cap. This is useful for the crazyflie
                                                  which default has way too much power. Defaults to float('inf').
            reversed_motors (list[int], optional): Reverse the motors (indexed from 1). Defaults to None.
            bidirectional_motors (bool, optional): Enable bidirectional motors. Defaults to False.
            uses_propellers (bool, optional): Whether the vehicle uses propellers.
                                              This is important as we need to linearize thrust if so. Defaults to True.
            sitl_address (str, optional): IP address of the SITL (useful with WSL2 eg \"172.24.220.98\").
                                          Defaults to "127.0.0.1".
        """
        # init class variables
        self.motor_velocity_cap = motor_velocity_cap
        self._instance = instance
        self._reversed_motors = reversed_motors
        self._bidirectional_motors = bidirectional_motors
        self._uses_propellers = uses_propellers
        self._webots_connected = True

        # setup Webots robot instance
        self.robot = Robot()

        # set robot time step relative to sim time step
        self._timestep = int(self.robot.getBasicTimeStep())

        # init sensors
        self.accel = self.robot.getDevice(accel_name)
        self.imu = self.robot.getDevice(imu_name)
        self.gyro = self.robot.getDevice(gyro_name)
        self.gps = self.robot.getDevice(gps_name)

        self.accel.enable(self._timestep)
        self.imu.enable(self._timestep)
        self.gyro.enable(self._timestep)
        self.gps.enable(self._timestep)

        # init camera
        if camera_name is not None:
            self.camera = self.robot.getDevice(camera_name)
            self.camera.enable(1000//camera_fps) # takes frame period in ms

            # start camera streaming thread if requested
            if camera_stream_port is not None:
                self._camera_thread = Thread(daemon=True,
                                             target=self._handle_image_stream,
                                             args=[self.camera, camera_stream_port])
                self._camera_thread.start()

        # init rangefinder
        if rangefinder_name is not None:
            self.rangefinder = self.robot.getDevice(rangefinder_name)
            self.rangefinder.enable(1000//rangefinder_fps) # takes frame period in ms

            # start rangefinder streaming thread if requested
            if rangefinder_stream_port is not None:
                self._rangefinder_thread = Thread(daemon=True,
                                                  target=self._handle_image_stream,
                                                  args=[self.rangefinder, rangefinder_stream_port])
                self._rangefinder_thread.start()

        # init motors (and setup velocity control)
        self._motors = [self.robot.getDevice(n) for n in motor_names]
        for m in self._motors:
            m.setPosition(float('inf'))
            m.setVelocity(0)

        # start ArduPilot SITL communication thread
        self._sitl_thread = Thread(daemon=True, target=self._handle_sitl, args=[sitl_address, 9002+10*instance])
        self._sitl_thread.start()

    def _handle_sitl(self, sitl_address: str = "127.0.0.1", port: int = 9002):
        """Handles all communications with the ArduPilot SITL

        Args:
            port (int, optional): Port to listen for SITL on. Defaults to 9002.
        """

        # create a local UDP socket server to listen for SITL
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # SOCK_STREAM
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind(('0.0.0.0', port))

        # wait for SITL to connect
        print(f"Listening for ardupilot SITL (I{self._instance}) at 127.0.0.1:{port}")
        self.robot.step(self._timestep) # flush print in webots console

        while not select.select([s], [], [], 0)[0]: # wait for socket to be readable
            # if webots is closed, close the socket and exit
            if self.robot.step(self._timestep) == -1:
                s.close()
                self._webots_connected = False
                return

        print(f"Connected to ardupilot SITL (I{self._instance})")

        # main loop handling communications
        while True:
            # check if the socket is ready to send/receive
            readable, writable, _ = select.select([s], [s], [], 0)

            # send data to SITL port (one lower than its output port as seen in SITL_cmdline.cpp)
            if writable:
                fdm_struct = self._get_fdm_struct()
                s.sendto(fdm_struct, (sitl_address, port+1))

            # receive data from SITL port
            if readable:
                data = s.recv(512)
                if not data or len(data) < self.controls_struct_size:
                    continue

                # parse a single struct
                command = struct.unpack(self.controls_struct_format, data[:self.controls_struct_size])
                self._handle_controls(command)

                # wait until the next Webots time step as no new sensor data will be available until then
                step_success = self.robot.step(self._timestep)
                if step_success == -1: # webots closed
                    break

        # if we leave the main loop then Webots must have closed
        s.close()
        self._webots_connected = False
        print(f"Lost connection to Webots (I{self._instance})")

    def _get_fdm_struct(self) -> bytes:
        """Form the Flight Dynamics Model struct (aka sensor data) to send to the SITL

        Returns:
            bytes: bytes representing the struct to send to SITL
        """
        # get data from Webots
        i = self.imu.getRollPitchYaw()
        g = self.gyro.getValues()
        a = self.accel.getValues()
        gps_pos = self.gps.getValues()
        gps_vel = self.gps.getSpeedVector()

        # pack the struct, converting ENU to NED (ish)
        # https://discuss.ardupilot.org/t/copter-x-y-z-which-is-which/6823/3
        # struct fdm_packet {
        #     double timestamp;
        #     double imu_angular_velocity_rpy[3];
        #     double imu_linear_acceleration_xyz[3];
        #     double imu_orientation_rpy[3];
        #     double velocity_xyz[3];
        #     double position_xyz[3];
        # };
        return struct.pack(self.fdm_struct_format,
                           self.robot.getTime(),
                           g[0], -g[1], -g[2],
                           a[0], -a[1], -a[2],
                           i[0], -i[1], -i[2],
                           gps_vel[0], -gps_vel[1], -gps_vel[2],
                           gps_pos[0], -gps_pos[1], -gps_pos[2])

    def _handle_controls(self, command: tuple):
        """Set the motor speeds based on the SITL command

        Args:
            command (tuple): tuple of motor speeds 0.0-1.0 where -1.0 is unused
        """

        # get only the number of motors we have
        command_motors = command[:len(self._motors)]
        if -1 in command_motors:
            print(f"Warning: SITL provided {command.index(-1)} motors "
                  f"but model specifies {len(self._motors)} (I{self._instance})")

        # scale commands to -1.0-1.0 if the motors are bidirectional (ex rover wheels)
        if self._bidirectional_motors:
            command_motors = [v*2-1 for v in command_motors]

        # linearize propeller thrust for `MOT_THST_EXPO=0`
        if self._uses_propellers:
            # `Thrust = thrust_constant * |omega| * omega` (ref https://cyberbotics.com/doc/reference/propeller)
            # if we set `omega = sqrt(input_thottle)` then `Thrust = thrust_constant * input_thottle`
            linearized_motor_commands = [np.sqrt(np.abs(v))*np.sign(v) for v in command_motors]

        # reverse motors if desired
        if self._reversed_motors:
            for m in self._reversed_motors:
                linearized_motor_commands[m-1] *= -1

        # set velocities of the motors in Webots
        for i, m in enumerate(self._motors):
            m.setVelocity(linearized_motor_commands[i] * min(m.getMaxVelocity(), self.motor_velocity_cap))

    def _handle_image_stream(self, camera: Union[Camera, RangeFinder], port: int):
        """Stream grayscale images over TCP

        Args:
            camera (Camera or RangeFinder): the camera to get images from
            port (int): port to send images over
        """

        # get camera info
        # https://cyberbotics.com/doc/reference/camera
        if isinstance(camera, Camera):
            cam_sample_period = self.camera.getSamplingPeriod()
            cam_width = self.camera.getWidth()
            cam_height = self.camera.getHeight()
            print(f"Camera stream started at 127.0.0.1:{port} (I{self._instance}) "
                  f"({cam_width}x{cam_height} @ {1000/cam_sample_period:0.2f}fps)")
        elif isinstance(camera, RangeFinder):
            cam_sample_period = self.rangefinder.getSamplingPeriod()
            cam_width = self.rangefinder.getWidth()
            cam_height = self.rangefinder.getHeight()
            print(f"RangeFinder stream started at 127.0.0.1:{port} (I{self._instance}) "
                  f"({cam_width}x{cam_height} @ {1000/cam_sample_period:0.2f}fps)")
        else:
            print(sys.stderr, f"Error: camera passed to _handle_image_stream is of invalid type "
                              f"'{type(camera)}' (I{self._instance})")
            return

        # create a local TCP socket server
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('127.0.0.1', port))
        server.listen(1)

        # continuously send images
        while self._webots_connected:
            # wait for incoming connection
            conn, _ = server.accept()
            print(f"Connected to camera client (I{self._instance})")

            # send images to client
            try:
                while self._webots_connected:
                    # delay at sample rate
                    start_time = self.robot.getTime()

                    # get image
                    if isinstance(camera, Camera):
                        img = self.get_camera_gray_image()
                    elif isinstance(camera, RangeFinder):
                        img = self.get_rangefinder_image()

                    if img is None:
                        print(f"No image received (I{self._instance})")
                        time.sleep(cam_sample_period/1000)
                        continue

                    # create a header struct with image size
                    header = struct.pack("=HH", cam_width, cam_height)

                    # pack header and image and send
                    data = header + img.tobytes()
                    conn.sendall(data)

                    # delay at sample rate
                    while self.robot.getTime() - start_time < cam_sample_period/1000:
                        time.sleep(0.001)

            except ConnectionResetError:
                pass
            except BrokenPipeError:
                pass
            finally:
                conn.close()
                print(f"Camera client disconnected (I{self._instance})")

    def get_camera_gray_image(self) -> np.ndarray:
        """Get the grayscale image from the camera as a numpy array of bytes"""
        img = self.get_camera_image()
        img_gray = np.average(img, axis=2).astype(np.uint8)
        return img_gray

    def get_camera_image(self) -> np.ndarray:
        """Get the RGB image from the camera as a numpy array of bytes"""
        img = self.camera.getImage()
        img = np.frombuffer(img, np.uint8).reshape((self.camera.getHeight(), self.camera.getWidth(), 4))
        return img[:, :, :3] # RGB only, no Alpha

    def get_rangefinder_image(self, use_int16: bool = False) -> np.ndarray:
        """Get the rangefinder depth image as a numpy array of int8 or int16"""\

        # get range image size
        height = self.rangefinder.getHeight()
        width = self.rangefinder.getWidth()

        # get image, and convert raw ctypes array to numpy array
        # https://cyberbotics.com/doc/reference/rangefinder
        image_c_ptr = self.rangefinder.getRangeImage(data_type="buffer")
        img_arr = np.ctypeslib.as_array(image_c_ptr, (width*height,))
        img_floats = img_arr.reshape((height, width))

        # normalize and set unknown values to max range
        range_range = self.rangefinder.getMaxRange() - self.rangefinder.getMinRange()
        img_normalized = (img_floats - self.rangefinder.getMinRange()) / range_range
        img_normalized[img_normalized == float('inf')] = 1

        # convert to int8 or int16, allowing for the option of higher precision if desired
        if use_int16:
            img = (img_normalized * 65535).astype(np.uint16)
        else:
            img = (img_normalized * 255).astype(np.uint8)

        return img

    def stop_motors(self):
        """Set all motors to zero velocity"""
        for m in self._motors:
            m.setPosition(float('inf'))
            m.setVelocity(0)

    def webots_connected(self) -> bool:
        """Check if Webots client is connected"""
        return self._webots_connected


#iris.wbt
# VRML_SIM R2023a utf8

EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/objects/backgrounds/protos/TexturedBackground.proto"
EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/objects/backgrounds/protos/TexturedBackgroundLight.proto"
EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/objects/road/protos/StraightRoadSegment.proto"
EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/objects/floors/protos/Floor.proto"
EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/appearances/protos/Grass.proto"
EXTERNPROTO "https://raw.githubusercontent.com/cyberbotics/webots/R2023a/projects/objects/advertising_board/protos/AdvertisingBoard.proto"
EXTERNPROTO "../protos/Iris.proto"

WorldInfo {
  title "Iris Ardupilot"
  basicTimeStep 1
  FPS 20
}
Viewpoint {
  orientation 0.15554153350599548 -0.8879632385984604 -0.4328141844398555 5.514055516141922
  position -2.719806534182175 -0.9451744343683601 2.1727182111093915
  follow "Iris"
  followSmoothness 0.01
}
TexturedBackground {
}
TexturedBackgroundLight {
}
Floor {
  size 300 100
  appearance Grass {
  }
}
AdvertisingBoard {
  translation 13.1012 17.8267 0
  rotation 0 0 1 -1.469
  frontTexture [
    "../../../../../Tools/autotest/web-firmware/images/logo.png"
  ]
  backTexture [
    "../../../../../Tools/autotest/web-firmware/images/logo.png"
  ]
  displayWidth 16.28
  displayHeight 6
  poleNumber 2
  poleType "H-shape"
  poleHeight 10
}
StraightRoadSegment {
  translation -15 0.3 0.02
  rotation 0 0 1 0.105
  width 16.5
  rightBorder FALSE
  leftBorder FALSE
  length 140
}
Iris {
  translation 0 0 0.09
  controller "ardupilot_vehicle_controller"
  controllerArgs [
    "--motors"
    "m1_motor, m2_motor, m3_motor, m4_motor"
  ]
  extensionSlot [
  ]
}


#As im still learning i have other nodes but they can they stop the drone even with manual commands does as do the nodes run at all? im not sure but here are ros nodes that i wated to put in but.

#setup.py
from setuptools import find_packages, setup

package_name = 'usl_control'

setup(
    name=package_name,
    version='0.0.0',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='synerglogic',
    maintainer_email='synerglogic@todo.todo',
    description='TODO: Package description',
    license='TODO: License declaration',
    extras_require={
        'test': [
            'pytest',
        ],
    },
    entry_points={
        'console_scripts': [
            'square_mission = usl_control.square_mission:main',
            'mavic_bridge = usl_control.mavic_bridge:main',
        ],
    },
)

#mission_manager 
#!/usr/bin/env python3
"""
Mission Manager Node
Publishes desired setpoints for square mission or other missions
"""
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy
from geometry_msgs.msg import PoseStamped
from geographic_msgs.msg import GeoPoint
from mavros_msgs.msg import State
from mavros_msgs.srv import CommandBool, SetMode
from geographic_msgs.srv import SetGeoPoint
import math

class MissionManager(Node):
    def __init__(self):
        super().__init__('mission_manager')
        
        # Parameters
        self.declare_parameter('mission_type', 'square')
        self.declare_parameter('square_size', 5.0)
        self.declare_parameter('altitude', 3.0)
        self.declare_parameter('position_threshold', 0.5)
        
        # MAVROS QoS profile
        mavros_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        
        # Publishers
        self.desired_setpoint_pub = self.create_publisher(
            PoseStamped,
            '/desired_setpoint',
            10
        )
        
        self.mavros_setpoint_pub = self.create_publisher(
            PoseStamped,
            '/mavros/setpoint_position/local',
            10
        )
        
        # Subscribers
        self.pose_sub = self.create_subscription(
            PoseStamped,
            '/mavros/local_position/pose',
            self.pose_callback,
            mavros_qos
        )
        
        self.state_sub = self.create_subscription(
            State,
            '/mavros/state',
            self.state_callback,
            mavros_qos
        )
        
        # Service clients
        self.arming_client = self.create_client(CommandBool, '/mavros/cmd/arming')
        self.set_mode_client = self.create_client(SetMode, '/mavros/set_mode')
        self.set_origin_client = self.create_client(SetGeoPoint, '/mavros/global_position/set_gp_origin')
        
        # State
        self.current_pose = None
        self.current_state = None
        self.home_position = None
        self.mission_state = 'INIT'
        self.current_waypoint_idx = 0
        self.origin_set = False
        
        # Generate waypoints
        self.waypoints = self.generate_waypoints()
        
        # Timer
        self.timer = self.create_timer(0.1, self.mission_loop)
        
        self.get_logger().info('Mission Manager initialized')
        self.get_logger().info(f'Generated {len(self.waypoints)} waypoints')
    
    def generate_waypoints(self):
        """Generate mission waypoints"""
        mission_type = self.get_parameter('mission_type').value
        square_size = self.get_parameter('square_size').value
        altitude = self.get_parameter('altitude').value
        
        if mission_type == 'square':
            waypoints = [
                {'x': 0.0, 'y': 0.0, 'z': altitude, 'yaw': 0.0},
                {'x': square_size, 'y': 0.0, 'z': altitude, 'yaw': 0.0},
                {'x': square_size, 'y': square_size, 'z': altitude, 'yaw': 1.57},
                {'x': 0.0, 'y': square_size, 'z': altitude, 'yaw': 3.14},
                {'x': 0.0, 'y': 0.0, 'z': altitude, 'yaw': -1.57},
            ]
        else:
            # Add other mission types here
            waypoints = [{'x': 0.0, 'y': 0.0, 'z': altitude, 'yaw': 0.0}]
        
        return waypoints
    
    def pose_callback(self, msg):
        self.current_pose = msg
        if self.home_position is None:
            self.home_position = msg
            self.get_logger().info(f'Home set: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})')
    
    def state_callback(self, msg):
        self.current_state = msg
    
    def set_mode(self, mode):
        req = SetMode.Request()
        req.custom_mode = mode
        future = self.set_mode_client.call_async(req)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)
        return future.result() if future.done() else None
    
    def arm(self):
        req = CommandBool.Request()
        req.value = True
        future = self.arming_client.call_async(req)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)
        return future.result() if future.done() else None
    
    def set_gps_origin(self):
        """Set GPS origin for ArduPilot"""
        req = SetGeoPoint.Request()
        req.geo_point.latitude = -35.363261
        req.geo_point.longitude = 149.165230
        req.geo_point.altitude = 584.0
        
        future = self.set_origin_client.call_async(req)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)
        return future.result() if future.done() else None
    
    def create_setpoint_msg(self, waypoint):
        """Create PoseStamped from waypoint dict"""
        pose = PoseStamped()
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.header.frame_id = "map"
        
        if self.home_position:
            pose.pose.position.x = self.home_position.pose.position.x + waypoint['x']
            pose.pose.position.y = self.home_position.pose.position.y + waypoint['y']
            pose.pose.position.z = self.home_position.pose.position.z + waypoint['z']
            
            # Convert yaw to quaternion
            cy = math.cos(waypoint['yaw'] * 0.5)
            sy = math.sin(waypoint['yaw'] * 0.5)
            pose.pose.orientation.w = cy
            pose.pose.orientation.z = sy
        
        return pose
    
    def distance_to_waypoint(self, waypoint):
        """Calculate distance to waypoint"""
        if self.home_position is None or self.current_pose is None:
            return float('inf')
        
        target_x = self.home_position.pose.position.x + waypoint['x']
        target_y = self.home_position.pose.position.y + waypoint['y']
        target_z = self.home_position.pose.position.z + waypoint['z']
        
        dx = target_x - self.current_pose.pose.position.x
        dy = target_y - self.current_pose.pose.position.y
        dz = target_z - self.current_pose.pose.position.z
        
        return math.sqrt(dx**2 + dy**2 + dz**2)
    
    def mission_loop(self):
        """Main mission state machine"""
        
        # Debug logging
        self.get_logger().info(f'State: {self.mission_state}', throttle_duration_sec=2.0)
        
        if self.mission_state == 'INIT':
            if self.current_state and self.current_state.connected:
                self.get_logger().info('MAVROS connected!')
                self.mission_state = 'WAIT_HOME'
        
        elif self.mission_state == 'WAIT_HOME':
            if self.home_position is not None:
                self.get_logger().info('Home position acquired!')
                self.mission_state = 'SET_ORIGIN'
            else:
                self.get_logger().info('Waiting for home...', throttle_duration_sec=2.0)
        
        elif self.mission_state == 'SET_MODE':
            if self.current_state.mode != "GUIDED":
                result = self.set_mode('GUIDED')
                if result and result.mode_sent:
                    self.get_logger().info('GUIDED mode set!')
            else:
                self.get_logger().info('Already in GUIDED mode')
                self.mission_state = 'ARM'
        
        elif self.mission_state == 'ARM':
            if not self.current_state.armed:
                result = self.arm()
                if result and result.success:
                    self.get_logger().info('Armed! Starting mission...')
                    self.mission_state = 'FLYING'
            else:
                self.get_logger().info('Already armed')
                self.mission_state = 'FLYING'
        
        elif self.mission_state == 'FLYING':
            if self.current_waypoint_idx < len(self.waypoints):
                waypoint = self.waypoints[self.current_waypoint_idx]
                setpoint = self.create_setpoint_msg(waypoint)
                
                # Publish to both topics
                self.desired_setpoint_pub.publish(setpoint)
                self.mavros_setpoint_pub.publish(setpoint)
                
                # Check if reached
                dist = self.distance_to_waypoint(waypoint)
                threshold = self.get_parameter('position_threshold').value
                
                if dist < threshold:
                    self.get_logger().info(
                        f'Waypoint {self.current_waypoint_idx + 1}/{len(self.waypoints)} reached'
                    )
                    self.current_waypoint_idx += 1
            else:
                self.get_logger().info('Mission complete!')
                self.mission_state = 'DONE'
        
        elif self.mission_state == 'DONE':
            # Keep publishing last setpoint to hold position
            if self.waypoints:
                last_waypoint = self.waypoints[-1]
                setpoint = self.create_setpoint_msg(last_waypoint)
                self.mavros_setpoint_pub.publish(setpoint)

def main(args=None):
    rclpy.init(args=args)
    node = MissionManager()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

#usl_system.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    return LaunchDescription([
        # Arguments
        DeclareLaunchArgument('square_size', default_value='5.0'),
        DeclareLaunchArgument('altitude', default_value='3.0'),
        DeclareLaunchArgument('enable_usl', default_value='true'),
        
        # Telemetry Monitor
        Node(
            package='usl_adaptive_control',
            executable='telemetry_monitor',
            name='telemetry_monitor',
            output='screen'
        ),
        
        # Mission Manager
        Node(
            package='usl_adaptive_control',
            executable='mission_manager',
            name='mission_manager',
            parameters=[{
                'square_size': LaunchConfiguration('square_size'),
                'altitude': LaunchConfiguration('altitude'),
            }],
            output='screen'
        ),
        
        # USL Controller
        Node(
            package='usl_adaptive_control',
            executable='usl_controller',
            name='usl_controller',
            parameters=[{
                'enable_correction': LaunchConfiguration('enable_usl'),
            }],
            output='screen'
        ),
    ])

#usl_controller.py
#!/usr/bin/env python3
"""
USL (Uncertainty-aware Self-Learning) Controller Node
Subscribes to telemetry and desired setpoints
Publishes corrected setpoints to compensate for disturbances
"""
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, TwistStamped
from sensor_msgs.msg import Imu
from mavros_msgs.msg import State
import numpy as np
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

class USLController(Node):
    def __init__(self):
        super().__init__('usl_controller')
        
        # Parameters
        self.declare_parameter('adaptation_gain', 0.5)
        self.declare_parameter('max_correction', 2.0)  # meters
        self.declare_parameter('enable_correction', True)
        
        # Publishers
        self.corrected_setpoint_pub = self.create_publisher(
            PoseStamped,
            '/mavros/setpoint_position/local',
            10
        )
        
        mavros_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )    
        
        # Subscribers
        self.desired_setpoint_sub = self.create_subscription(
            PoseStamped,
            '/desired_setpoint',
            self.desired_setpoint_callback,
            mavros_qos
        )
        
        self.pose_sub = self.create_subscription(
            PoseStamped,
            '/mavros/local_position/pose',
            self.pose_callback,
            mavros_qos
        )
        
        self.velocity_sub = self.create_subscription(
            TwistStamped,
            '/mavros/local_position/velocity_local',
            self.velocity_callback,
            mavros_qos
        )
        
        self.imu_sub = self.create_subscription(
            Imu,
            '/mavros/imu/data',
            self.imu_callback,
            mavros_qos
        )
        
        # State
        self.desired_setpoint = None
        self.current_pose = None
        self.current_velocity = None
        self.current_imu = None
        
        # Adaptation state
        self.disturbance_estimate = np.zeros(3)
        self.error_integral = np.zeros(3)
        
        # Timer
        self.timer = self.create_timer(0.1, self.control_loop)
        
        self.get_logger().info('USL Controller initialized')
    
    def desired_setpoint_callback(self, msg):
        self.desired_setpoint = msg
    
    def pose_callback(self, msg):
        self.current_pose = msg
    
    def velocity_callback(self, msg):
        self.current_velocity = msg
    
    def imu_callback(self, msg):
        self.current_imu = msg
    
    def estimate_disturbance(self):
        """Estimate external disturbances (wind, model mismatch, etc.)"""
        if self.desired_setpoint is None or self.current_pose is None:
            return
        
        # Position error
        error = np.array([
            self.desired_setpoint.pose.position.x - self.current_pose.pose.position.x,
            self.desired_setpoint.pose.position.y - self.current_pose.pose.position.y,
            self.desired_setpoint.pose.position.z - self.current_pose.pose.position.z
        ])
        
        # Adaptive gain
        gain = self.get_parameter('adaptation_gain').value
        
        # Update disturbance estimate (simple integrator for now)
        self.disturbance_estimate += gain * error * 0.1  # dt = 0.1
        
        # Clip to max correction
        max_corr = self.get_parameter('max_correction').value
        self.disturbance_estimate = np.clip(self.disturbance_estimate, -max_corr, max_corr)
    
    def control_loop(self):
        """Main control loop"""
        if self.desired_setpoint is None:
            return
        
        # Estimate disturbances
        self.estimate_disturbance()
        
        # Create corrected setpoint
        corrected = PoseStamped()
        corrected.header = self.desired_setpoint.header
        corrected.header.stamp = self.get_clock().now().to_msg()
        
        enable_correction = self.get_parameter('enable_correction').value
        
        if enable_correction:
            # Add disturbance compensation
            corrected.pose.position.x = (
                self.desired_setpoint.pose.position.x + self.disturbance_estimate[0]
            )
            corrected.pose.position.y = (
                self.desired_setpoint.pose.position.y + self.disturbance_estimate[1]
            )
            corrected.pose.position.z = (
                self.desired_setpoint.pose.position.z + self.disturbance_estimate[2]
            )
        else:
            # Pass through without correction
            corrected.pose.position = self.desired_setpoint.pose.position
        
        # Keep same orientation
        corrected.pose.orientation = self.desired_setpoint.pose.orientation
        
        # Publish
        self.corrected_setpoint_pub.publish(corrected)
        
        # Log if significant disturbance
        dist_mag = np.linalg.norm(self.disturbance_estimate)
        if dist_mag > 0.1:
            self.get_logger().info(
                f'Disturbance: [{self.disturbance_estimate[0]:.2f}, '
                f'{self.disturbance_estimate[1]:.2f}, '
                f'{self.disturbance_estimate[2]:.2f}] | Mag: {dist_mag:.2f}m'
            )

def main(args=None):
    rclpy.init(args=args)
    node = USLController()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()


#telemetry_monitor.py
#!/usr/bin/env python3
"""
Telemetry Monitor Node
Subscribes to all relevant MAVROS topics and logs/stores data for USL analysis
"""
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, TwistStamped
from sensor_msgs.msg import Imu, BatteryState
from mavros_msgs.msg import State
import numpy as np
from collections import deque
import time
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy, DurabilityPolicy

class TelemetryMonitor(Node):
    def __init__(self):
        super().__init__('telemetry_monitor')
        
        # Declare parameters
        self.declare_parameter('history_length', 100)  # Store last N samples
        self.declare_parameter('publish_rate', 10.0)   # Hz
        
        history_len = self.get_parameter('history_length').value
        
        # Data storage - using deque for efficient ring buffer
        self.pose_history = deque(maxlen=history_len)
        self.velocity_history = deque(maxlen=history_len)
        self.imu_history = deque(maxlen=history_len)
        
        # Current state
        self.current_pose = None
        self.current_velocity = None
        self.current_imu = None
        self.current_battery = None
        self.current_state = None
        
        # Statistics
        self.stats = {
            'pose_rate': 0.0,
            'velocity_rate': 0.0,
            'imu_rate': 0.0,
        }
        self._last_stats_time = time.time()
        self._message_counts = {'pose': 0, 'velocity': 0, 'imu': 0}
        
        # QoS Profile - added for ros
        mavros_qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,       
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        
        # === SUBSCRIBERS ===
        self.pose_sub = self.create_subscription(
            PoseStamped,
            '/mavros/local_position/pose',
            self.pose_callback,
            mavros_qos
        )
        
        self.velocity_sub = self.create_subscription(
            TwistStamped,
            '/mavros/local_position/velocity_local',
            self.velocity_callback,
            mavros_qos
        )
        
        self.imu_sub = self.create_subscription(
            Imu,
            '/mavros/imu/data',
            self.imu_callback,
            mavros_qos
        )
        
        self.battery_sub = self.create_subscription(
            BatteryState,
            '/mavros/battery',
            self.battery_callback,
            mavros_qos
        )
        
        self.state_sub = self.create_subscription(
            State,
            '/mavros/state',
            self.state_callback,
            mavros_qos
        )
        
        # Timer for periodic logging
        rate = self.get_parameter('publish_rate').value
        self.timer = self.create_timer(1.0 / rate, self.monitor_loop)
        
        self.get_logger().info('Telemetry Monitor initialized')
        self.get_logger().info(f'History length: {history_len} samples')
    
    def pose_callback(self, msg):
        """Store pose data"""
        self.current_pose = msg
        self.pose_history.append({
            'timestamp': time.time(),
            'position': np.array([
                msg.pose.position.x,
                msg.pose.position.y,
                msg.pose.position.z
            ]),
            'orientation': np.array([
                msg.pose.orientation.w,
                msg.pose.orientation.x,
                msg.pose.orientation.y,
                msg.pose.orientation.z
            ])
        })
        self._message_counts['pose'] += 1
    
    def velocity_callback(self, msg):
        """Store velocity data"""
        self.current_velocity = msg
        self.velocity_history.append({
            'timestamp': time.time(),
            'linear': np.array([
                msg.twist.linear.x,
                msg.twist.linear.y,
                msg.twist.linear.z
            ]),
            'angular': np.array([
                msg.twist.angular.x,
                msg.twist.angular.y,
                msg.twist.angular.z
            ])
        })
        self._message_counts['velocity'] += 1
    
    def imu_callback(self, msg):
        """Store IMU data"""
        self.current_imu = msg
        self.imu_history.append({
            'timestamp': time.time(),
            'linear_acceleration': np.array([
                msg.linear_acceleration.x,
                msg.linear_acceleration.y,
                msg.linear_acceleration.z
            ]),
            'angular_velocity': np.array([
                msg.angular_velocity.x,
                msg.angular_velocity.y,
                msg.angular_velocity.z
            ])
        })
        self._message_counts['imu'] += 1
    
    def battery_callback(self, msg):
        """Store battery data"""
        self.current_battery = msg
    
    def state_callback(self, msg):
        """Store state data"""
        self.current_state = msg
    
    def update_statistics(self):
        """Calculate message rates"""
        current_time = time.time()
        elapsed = current_time - self._last_stats_time
        
        if elapsed > 0:
            self.stats['pose_rate'] = self._message_counts['pose'] / elapsed
            self.stats['velocity_rate'] = self._message_counts['velocity'] / elapsed
            self.stats['imu_rate'] = self._message_counts['imu'] / elapsed
            
            # Reset counters
            self._message_counts = {'pose': 0, 'velocity': 0, 'imu': 0}
            self._last_stats_time = current_time
    
    def get_position_deviation(self, window_size=10):
        """Calculate recent position deviation (useful for detecting drift)"""
        if len(self.pose_history) < window_size:
            return 0.0
        
        recent_positions = [p['position'] for p in list(self.pose_history)[-window_size:]]
        mean_pos = np.mean(recent_positions, axis=0)
        deviations = [np.linalg.norm(p - mean_pos) for p in recent_positions]
        return np.mean(deviations)
    
    def monitor_loop(self):
        """Periodic monitoring and logging"""
        self.update_statistics()
        
        # Log current state
        if self.current_state is not None:
            status_msg = (
                f"State: {self.current_state.mode} | "
                f"Armed: {self.current_state.armed} | "
                f"Connected: {self.current_state.connected}"
            )
            
            if self.current_pose is not None:
                pos = self.current_pose.pose.position
                status_msg += f" | Pos: ({pos.x:.2f}, {pos.y:.2f}, {pos.z:.2f})"
            
            if self.current_velocity is not None:
                vel = self.current_velocity.twist.linear
                speed = np.linalg.norm([vel.x, vel.y, vel.z])
                status_msg += f" | Speed: {speed:.2f} m/s"
            
            if self.current_battery is not None:
                status_msg += f" | Battery: {self.current_battery.percentage:.1f}%"
            
            # Log rates every 5 seconds
            if int(time.time()) % 5 == 0:
                self.get_logger().info(
                    f"Rates - Pose: {self.stats['pose_rate']:.1f}Hz, "
                    f"Vel: {self.stats['velocity_rate']:.1f}Hz, "
                    f"IMU: {self.stats['imu_rate']:.1f}Hz"
                )
    
    def get_current_telemetry(self):
        """Return current telemetry snapshot (for other nodes to use)"""
        return {
            'pose': self.current_pose,
            'velocity': self.current_velocity,
            'imu': self.current_imu,
            'battery': self.current_battery,
            'state': self.current_state,
            'stats': self.stats
        }

def main(args=None):
    rclpy.init(args=args)
    node = TelemetryMonitor()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
